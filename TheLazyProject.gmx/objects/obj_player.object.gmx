<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_player_mask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init variables

spd = 6
jspd = 14
//Horizontal and Vertical
hspd = 0
vspd = 0

//gravity
grav = 2

//acceleration
acc = 1;


//For proper resize, we need to set the sprite origin to bottom.
//The reason why don't manipulate image_scale directly is because
//it changes the collision masks as well. When the collision mask constantly changes
//You can run into mistakes like the player stuck in a wall.
//By separating it, collision and sprite resize becomes two different things.
draw_xscale = 1.0;
draw_yscale = 1.0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get Input, change sprite, and Collision
right = keyboard_check(vk_right);
left = keyboard_check(vk_left);
up = keyboard_check_pressed(vk_up);
up_release = keyboard_check_released(vk_up);
down = keyboard_check(vk_down);

//Movement
//Gravity Fall
if (!place_meeting(x,y+1,obj_solid)){
    vspd += grav;
} else {
    //If we hit the ground
    vspd = 0;
}

//Left right movement
if (right || left){
    hspd += (right - left) * acc;
    hspd = ternary((hspd &gt; spd), spd, hspd);
    //no ternary operator, had to make my own lol
    hspd = ternary((hspd &lt; -spd), -spd, hspd);
} else {
    //Friction
    //urg, nested ifs
    if (hspd != 0){
        if (abs(hspd)-acc &gt; 0){
            if (hspd &gt; 0){
                hspd -= acc;
            }else{
                hspd -= -acc;
            }
        } else{
            hspd = 0;
        }
    }
}

//By changing the image_xscale, we change the collision mask as well.
//This prevents most obvious collision mistakes where the character is partly inside a 
//solid block.
/*
if (place_meeting(x, y+1, obj_solid)){
    image_xscale = draw_xscale;
    image_yscale = draw_yscale;
}
//This is kind of broken, not sure how to fix it.
*/

//Jump
if (up &amp;&amp; place_meeting(x,y+1,obj_solid)){
    vspd = -jspd;
    //Resize when jump
    draw_yscale = 1.5;
    draw_xscale = .75;
    
}
//Jump control
if (up_release &amp;&amp; vspd &lt; -6 &amp;&amp; !place_meeting(x,y+1,obj_solid)){
    vspd = -6
    //Resize
    draw_yscale = 1.2;
    draw_xscale = .85;
}


collision_and_movement(obj_solid);

//Sprite change
/*
By having sprite change after collision and movement
whatever speed you have is reflected upon the sprites.
*/
if (hspd == 0 &amp;&amp; place_meeting(x,y+1,obj_solid)){
    sprite_index = spr_player_idle;
    image_speed = 0;
}

if (hspd != 0 &amp;&amp; place_meeting(x,y+1,obj_solid)){
    sprite_index = spr_player_walk;
    image_speed = 0.3;

}

if (vspd != 0 &amp;&amp; !place_meeting(x, y+1, obj_solid)){
    sprite_index = spr_player_jump;
    image_speed = 0;
}

//Returning to original size from resize
if (place_meeting(x, y+1, obj_solid)){
    //Going back to original size much slower
    draw_xscale = lerp(draw_xscale, 1, 0.1);
    draw_yscale = lerp(draw_yscale, 1, 0.1);
}else{
    //Goes to original size faster in air
    draw_xscale = lerp(draw_xscale, 1, 0.20);
    draw_yscale = lerp(draw_yscale, 1, 0.20);
}


//Landing resize (dependent on speed)
if (place_meeting(x, y+1, obj_solid) &amp;&amp; !place_meeting(x, yprevious+1, obj_solid)){
    draw_yscale = 1 - ((y - yprevious) * 0.01);
    draw_xscale = 1 + ((y - yprevious) * 0.02);
    //Distance away from left and/or right edge when going back to original size.
    if (place_meeting(x+1, y, obj_solid)){
        x -= (3 * ((y - yprevious) * 0.07))
    }
    if (place_meeting(x-1, y, obj_solid)){
        x += (3 * ((y - yprevious) * 0.07))
    }
}




//Camera Movement
view_xview[0] += ((x-(view_wview[0]/2)) - view_xview[0]) * 0.1;
view_yview[0] += ((y-(view_hview[0]/2)) - view_yview[0]) * 0.1;
if (view_yview[0] &lt;= 35){
    view_yview[0] -= ((y-(view_hview[0]/2)) - view_yview[0]) * (((35-view_yview[0])/35)*0.1);
}
//Prevents view from going off room
//view_xview[0] = clamp(view_xview[0],0, room_width-view_wview[0]);
//view_yview[0] = clamp(view_yview[0],0, room_height-view_hview[0]);








</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the sprite
draw_sprite_ext(sprite_index, image_index, x, y, draw_xscale, draw_yscale, image_angle, image_blend, image_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>

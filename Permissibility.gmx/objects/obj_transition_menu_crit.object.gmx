<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_menu_transition</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup variables

//Only one transition object can exists in the menu room

/*
-Draw and enlarge Circle
-Draw and Slide bar
-Stagger and bring items
-fade in button
*/

//To make sure this is drawn above everything
depth = -5;

//Keep object alive when changing rooms
persistent = true;

//Surface and Frames
current_frame = 0;
//Copy menu surface
sur_menu = surface_create(room_width, room_height);
surface_copy(sur_menu, 0, 0, application_surface);

//Room recorded, go to next room
room_goto(rm_criteria);


//Circle coords
draw_set_circle_precision(68);
cir_x = x;
cir_y = y;
radius = 0;
max_radius = point_distance(cir_x, cir_y, room_width, room_height);
cir_seconds = 0;
cir_max_seconds = 15/60;
cir_color = make_colour_rgb(114, 77, 159);

//Bar coords
bar_height = 0;
bar_max_height = 1660;
bar_seconds = 0;
bar_max_seconds = 30/60;

//Checkboxes
checkbox_initial_x = -110;
checkbox_final_x = 115;
checkbox_max_seconds = 18/60;

//Initialize array with all values set to zero 
//from index 0 to 2
checkbox_seconds[2] = 0;

//Checkbox x will be set later in the step event
//so leaving zero is okay
checkbox_x[2] = 0;

//For for loop traversal in draw event
checkbox_y[0] = 353;
checkbox_y[1] = 763;
checkbox_y[2] = 1173;

//Draw text from surface
crit_text_x = 335
crit_text_x_max = 365
crit_text_alpha = 0.7;
crit_text_seconds = 0;
crit_text_max_seconds = 15/60;

text_x[2] = 0;
text_seconds[2] = 0;
text_max_seconds = 20/60;

//Draw Button from surface
button_alpha = 0;
button_seconds = 0;
button_max_seconds = 30/60;

//streaks coords
streaks_x = room_width + sprite_get_width(spr_top_streaks)/1.5;
streaks_x_final = room_width;
streaks_seconds = 0;
streaks_max_seconds = 1/2;


//Surface variables
sur_crit = -1;
sur_context = -1;
sur_meaning = -1;
sur_posiv = -1;
sur_button = -1;







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create transition

//increment frame to keep track of room change
if (current_frame &lt;= 5) {
    current_frame += 1;
}

//Copy next room look
if (current_frame == 2) {
    sur_criteria = surface_create(room_width, room_height);
    surface_copy(sur_criteria, 0, 0, application_surface);
}


//Transition animations
var seconds_passed = global.seconds_passed;

//Enlarge circle
if (cir_seconds &lt; cir_max_seconds) {
    cir_seconds += seconds_passed;
    radius = scr_ease_in_cubic(cir_seconds, 0, max_radius, cir_max_seconds);
    //won't execute any animations until this finishes
    exit;
}

//Bring White Bar up
if (bar_seconds &lt; bar_max_seconds){
    bar_seconds += seconds_passed;
    bar_seconds = min(bar_seconds, bar_max_seconds);
    bar_height = scr_ease_out_quart(bar_seconds, 0, bar_max_height, bar_max_seconds);
    exit;
}

//Animate Criteria title
if (crit_text_seconds &lt; crit_text_max_seconds) {
    crit_text_seconds += seconds_passed;
    crit_text_seconds = min(crit_text_seconds, crit_text_max_seconds);
    crit_text_x = scr_ease_out_cubic(crit_text_seconds, 335, crit_text_x_max - 335, crit_text_max_seconds);
    crit_text_alpha = scr_linear_tween(crit_text_seconds, 0, 1, crit_text_max_seconds);
}

if (!surface_exists(sur_criteria)) {
    instance_destroy();
}

if (!surface_exists(sur_crit)) {
    sur_crit = surface_create(343, 103);
    surface_copy_part(sur_crit, 0, 0, sur_criteria, 365, 71, 343, 103);
}


if (crit_text_seconds &lt;= 2 * crit_text_max_seconds/3) {
    exit;
}

//Animate streaks
if (streaks_seconds &lt; streaks_max_seconds) {
    streaks_seconds += seconds_passed;
    streak_seconds = min(streaks_seconds, streaks_max_seconds);
    streaks_x = scr_ease_out_expo(streaks_seconds, room_width + sprite_get_width(spr_top_streaks)/1.5,
        -sprite_get_width(spr_top_streaks)/1.5, streaks_max_seconds);
}

if (streaks_seconds &lt;= (1/4) * streaks_max_seconds) {
    exit;
}

//Bring in checkboxes
for (var i = 0; i &lt; 3; i++) {
    if (checkbox_seconds[i] &lt; checkbox_max_seconds){
        checkbox_seconds[i] += seconds_passed;
        checkbox_seconds[i] = min(checkbox_seconds[i], checkbox_max_seconds);
        checkbox_x[i] = scr_ease_out_quart(checkbox_seconds[i],
            checkbox_initial_x, checkbox_final_x - checkbox_initial_x, checkbox_max_seconds);
    }
    
    //If animation is more than 1/3 played, bring in more checkboxes and text
    if (checkbox_seconds[i] &lt;= checkbox_max_seconds * 1/3){
        exit;
    }
    
    //Bring in the text next to checkbox
    if (text_seconds[i] &lt; text_max_seconds) {
        text_seconds[i] += seconds_passed;
        text_seconds[i] = min(text_seconds[i], text_max_seconds);
        text_x[i] = scr_ease_out_quart(text_seconds[i],
            room_width, 283 - room_width, text_max_seconds);
    }
}

//If original surface does not exist, end animation
//Surfaces are volatile
if (!surface_exists(sur_criteria)) {
    instance_destroy();
}

//Check surfaces
//If text is animating, and surface is not there, create a brand new surface... 
if (text_seconds[0] != 0 &amp;&amp; !surface_exists(sur_context)){
    sur_context = surface_create(665, 226);
    surface_copy_part(sur_context, 0, 0, sur_criteria, 283, 338, 665, 226);
}

if (!surface_exists(sur_criteria)) {
    instance_destroy();
}

if (text_seconds[1] != 0 &amp;&amp; !surface_exists(sur_meaning)) {
    sur_meaning = surface_create(665, 226);
    surface_copy_part(sur_meaning, 0, 0, sur_criteria, 283, 763, 665, 226);

}

if (!surface_exists(sur_criteria)) {
    instance_destroy();
}

if (text_seconds[2] != 0 &amp;&amp; !surface_exists(sur_posiv)) {
    sur_posiv = surface_create(665, 278);
    surface_copy_part(sur_posiv, 0, 0, sur_criteria, 283, 1161, 665, 278);

}

if (text_seconds[2] &lt;= 2 * text_max_seconds/3){
    exit;
}

//Animate button
if (button_seconds &lt; button_max_seconds) {
    button_seconds += seconds_passed;
    button_seconds = min(button_seconds, button_max_seconds);
    button_alpha = scr_linear_tween(button_seconds, 0, 1, button_max_seconds);
}

if (!surface_exists(sur_criteria)) {
    instance_destroy();
}

if (!surface_exists(sur_button)){
    sur_button = surface_create(666, 227);
    surface_copy_part(sur_button, 0, 0, sur_criteria, 208, 1552, 666, 227);

}

if (button_seconds &gt;= button_max_seconds) {
    surface_free(sur_criteria)    
    surface_free(sur_crit)
    surface_free(sur_context)
    surface_free(sur_meaning)
    surface_free(sur_posiv)
    surface_free(sur_button)
    surface_free(sur_menu)
    instance_destroy();
}






</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw split second surface on screen

/*
The reason why we do this is unknown. Game Maker Studio displays the next room
and in order to prevent the next room from flashing up, we draw it over it
The reason why we do it in the Draw GUI event is to prevent the drawing 
of this split second frame from obstructing the the copying of the application surface.
GUI and Draw are separate, by drawing here, we can let the step event copy next room
while showing nothing happened.
*/
if (current_frame == 1) {
    if (surface_exists(sur_menu)){
        /*
        When Game Maker auto resize the screen
        Game Maker does not resize the GUI properly
        so I have to resize it myself
        */
        display_set_gui_size(view_wport[0], view_hport[0]);
        //draw_surface(sur_menu, 0, 0); 
        /*
        Since sur_menu is a surface that has the size of the application surface
        the size does not correspond to the auto resized view port of the game
        */
        draw_surface_stretched(sur_menu, 0, 0, view_wport[0], view_hport[0]);  
    }
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw transition
//Stuff doesn't draw well on windows because
//there's a conflict between resolutions
//I am using too big of a resolution that even my computer cannot
//show the whole window
//Since I'm using 1080p, Game Maker auto resize the window to show the whole game screen
//This auto resizing creates a conflict with my room size with my GUI size, and various
//other drawing screens, I think because it affected the application surface
//Many surface related operations gets messed up on resize.
//Unless I develop this game under smaller resolutions, don't think I can avoid this.
//Even when you use it fullscreen and it tells you it's running 1080p
//It's not, the drawings are still messed up.
//Only if your display actually fits 1080p portrait, like a phone does it actually
//run well. (All GUI, application surface, drawing all fits perfectly for the room)

if (current_frame &gt; 1 &amp;&amp; surface_exists(sur_menu)) {
    draw_surface(sur_menu, 0, 0);
}

/*
if (current_frame &gt; 1 &amp;&amp; surface_exists(sur_criteria)) {
    draw_surface(sur_criteria, -surface_get_width(sur_criteria), 0);
}
*/


//Draw animation on surface
if (surface_exists(sur_menu)) {
    surface_set_target(sur_menu);
}
//Draw circle
scr_draw_col_alph(cir_color, 1);
draw_circle(cir_x, cir_y, radius, false);

//Draw rectangle
if (bar_height != 0){
    scr_draw_col_alph(c_white, 1);
    draw_rectangle(0, room_height - bar_height, room_width, room_height, false);
}

//Draw streaks
if (streaks_seconds != 0) {
    draw_sprite(spr_top_streaks, 0, streaks_x, 126);
}

//Draw checkbox
for (var i = 0; i &lt; 3; i++) {
    if (checkbox_seconds[i] != 0) {
        draw_sprite(spr_purp_check, 0, checkbox_x[i], checkbox_y[i]);
    }
    
    if (checkbox_seconds[i] == 0){
        break;
    }
}

//Draw criteria
if (crit_text_seconds != 0 &amp;&amp; surface_exists(sur_crit)) {
    draw_surface_ext(sur_crit, crit_text_x, 71, 1, 1, 0, c_white, crit_text_alpha);
}

if (text_seconds[0] != 0 &amp;&amp; surface_exists(sur_context)) {
    draw_surface(sur_context, text_x[0], 338);
}

if (text_seconds[1] != 0 &amp;&amp; surface_exists(sur_meaning)) {
    draw_surface(sur_meaning, text_x[1], 763);
}

if (text_seconds[2] != 0 &amp;&amp; surface_exists(sur_posiv)) {
    draw_surface(sur_posiv, text_x[2], 1161);
}

if (button_seconds != 0 &amp;&amp; surface_exists(sur_button)) {
    draw_surface_ext(sur_button, 208, 1552, 1, 1, 0, c_white, button_alpha);
}

surface_reset_target();


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
